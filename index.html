<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ðŸª¢ Knottingham ðŸª¢</title>
    <meta author content="">
    <link rel="stylesheet" href="../css/style.css">
    <script type="text/javascript" src="js/paper.js"></script>
    <script type="text/paperscript" canvas="canvas">
        // Some functions in global scope to interoperate with the
        // non-paperscript code:
        globals.updateStyle = function() {
          activeKnot.strokeWidth = globals.strokeWidth;
          activeKnot.strokeColor = globals.strokeColor;
        }
        globals.straighten = function(){activeKnot.clearHandles();showIntersections();smooth = false;}
        globals.toSVG = function(){return project.exportSVG({bounds:'content'});}
        globals.toJSON = function() { // Does not work for multiple knots
          var obj = activeKnot.exportJSON({asString:false});
          return JSON.stringify([obj, intersectionWatcher]);
        }
        globals.fromJSON = function(jsonString) { // Does not work for multiple knots
          var obj = JSON.parse(jsonString);
          activeKnot.importJSON(JSON.stringify(obj[0]));
          var intersections = obj[1];
          intersectionWatcher = [[],[]];
          for (var k = 0; k < intersections[1].length; k++) {
            intersectionWatcher[1][k] = intersections[1][k];
            intersectionWatcher[0][k] = new Point(intersections[0][k][1], intersections[0][k][2]);
          }
        }
        globals.select = function(){
          var bool = activeKnot.fullySelected;
          activeKnot.fullySelected = false;
          activeKnot.fullySelected = !bool;
        }
        globals.draw = function(){drawing = true; project.clear();globals.smooth=false;}

        var hitOptions = {
					segments: true,
					stroke: true,
          handles: true,
					fill: true,
					tolerance: 5
				};

        var intersectionWatcher = [[],[]];

        var neighbors = 1;

        var drawing = false;
        var intersectionRadius = 1;
        var strokeColor = 'black';


        var knot = new Path();
				knot.strokeColor = strokeColor;
				knot.strokeWidth = window.globals.strokeWidth;
        //knot.shadowColor = new Color(0, 0, 0);
        //knot.shadowOffset = new Point(6, 6)
        //knot.shadowBlur = 10;
        knot.selected = true;
        knot.data = {kind: 'knot'};
        var activeKnot = knot.clone();
        knot.remove();

        var conway = '[["Path",{"applyMatrix":true,"data":{"z":[120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600,610,620,630,640,650,660,670,680,690,700,710,720,730,740,750,760,770,780,790,800,810,820,830,840,850,860,870,880,890,900,910,920,930,940,950,960,970,980,990]},"segments":[[[421.28466,311.56804],[-21.988,34.57573],[21.988,-34.57573]],[[541.15302,199.60118],[-42.61808,20.11581],[42.61808,-20.11581]],[[617.04883,224.11296],[-3.30386,-27.58387],[3.30386,27.58387]],[[577.8222,310.56682],[19.16435,-20.74597],[-19.16435,20.74597]],[[530.24102,334.85465],[13.45424,-0.17394],[-13.45424,0.17394]],[[478.36779,303.2304],[26.47305,28.77815],[-26.47305,-28.77815]],[[414.19627,190.11536],[-3.3017,29.80063],[3.3017,-29.80063]],[[493.65076,173.74515],[-28.54922,-18.49542],[28.54922,18.49542]],[[550.60688,262.40743],[-18.91203,-28.11102],[18.91203,28.11102]],[[608.26824,331.27713],[-10.42014,-26.59249],[10.42014,26.59249]],[[581.63596,413.43788],[29.56351,-16.54948],[-29.56351,16.54948]],[[489.83504,395.17333],[10.59931,28.8942],[-10.59931,-28.8942]],[[514.97928,277.83947],[-5.30411,36.57109],[5.30411,-36.57109]],[[467.17824,217.31252],[33.27391,2.68226],[-33.27391,-2.68226]],[[366.41896,264.08378],[20.76878,-33.54446],[-20.76878,33.54446]],[[371.42595,384.71931],[-20.59676,-35.91124],[20.59676,35.91124]],[[462.11965,437.62161],[-34.08242,3.6516],[34.08242,-3.6516]],[[529.96498,384.4633],[-1.61257,21.56086],[1.61257,-21.56086]],[[454.88923,345.90073],[47.76312,1.82584],[-47.76312,-1.82584]],[[322.21835,377.89199],[18.30672,-22.29293],[-18.30672,22.29293]],[[358.58189,433.71775],[-24.68264,-0.47114],[24.68264,0.47114]],[[406.35977,380.17742],[-3.71756,21.89207],[3.71756,-21.89207]]],"closed":true,"strokeColor":[0,0,0],"strokeWidth":5}],[[["Point",354.29196,296.73364],["Point",400.34859,268.75223],["Point",388.16833,221.33261],["Point",383.31948,123.98353],["Point",400.34859,268.75223],["Point",400.34859,268.75223],["Point",386.01652,273.14906],["Point",386.75007,272.96203],["Point",386.75007,272.96203],["Point",385.77298,264.5154],["Point",385.77298,264.5154]],[true,false,true,false,true,true,true,false,false,true,false]]]';
        globals.fromJSON(conway);

				var intersections = activeKnot.getIntersections(activeKnot);

				function showIntersections() {

					intersections = activeKnot.getCrossings(activeKnot);


          // Map observed intersections to previous intersections
          if (intersectionWatcher[0].length < intersections.length) {
            for (var i = 0; i < intersections.length - intersectionWatcher[0].length; i++) {
              var intersect = intersections[i];

              intersectionWatcher[0].push(intersect.point);
              intersectionWatcher[1].push(false);
            }
          }
          else if (intersectionWatcher[0].length > intersections.length) {
            for (var i = 0; i < intersectionWatcher[0].length - intersections.length; i++) {
              intersectionWatcher[0].splice(0,1);
              intersectionWatcher[1].splice(0,1);
            }
          }
          /* well... except it doesn't work yet
          else if (intersectionWatcher.length == intersections.length) {
            var indeces = Array.from(Array(intersectionWatcher.length).keys());
            var tempWatcher = [[],[]];

            for (var k = 0; k < intersections.length; k++) {
              var point = intersections[k];
              var i = 0;
              var min = 999999;
              for (var index in indeces) {
                var distance = intersectionWatcher[0][index].getDistance(point);
                if (distance < min) {
                  min = distance;
                  i = index;
                }
              }
              indeces.splice(i, 1);
              tempWatcher[0].push(intersections[i]);
              tempWatcher[1].push(intersectionWatcher[1][i])
            }
            intersectionWatcher = tempWatcher;

          }
          */
					for (var i = 0; i < intersections.length; i++) {
              var intersect = intersections[i];

              // This would need to be two variables for multiple knots.
              var path = intersect.path;
              var center = intersect.point;

              var i1 = intersect.curve.index;
              var i2 = intersect.intersection.curve.index;

              intersect.curve.data = {};

              var curve1 = intersect.curve;
              var curve2 = intersect.intersection.curve;
              var t1 = intersect.time;
              var t2 = intersect.intersection.time;

              var tangent1 = intersect.tangent;
              var tangent2 = intersect.intersection.tangent;

              if (intersectionWatcher[1][i]) {
                t1 = intersect.intersection.time;
                t2 = intersect.time;
                tangent1 = intersect.intersection.tangent;
                tangent2 = intersect.tangent;
                curve1 = intersect.intersection.curve;
                curve2 = intersect.curve;
              }
              var radius = (15 * Math.abs(tangent1.dot(tangent2)) + 2 * globals.strokeWidth) / curve1.length;
              var segments = [curve1.getPart(t1 - radius, t1 + radius).segment1.clone(), curve1.getPart(t1 - radius, t1 + radius).segment2.clone()];


              var path = new Path({
                  segments: segments,
                  strokeColor: 'white',
                  strokeWidth: window.globals.gapWidth * window.globals.strokeWidth,
                  data: {kind: 'intersection', i1: i, path: path}
              }).removeOnMove().removeOnDrag();


              var path3 = new Path({
                  segments: segments,
                  strokeColor: window.globals.showIntersections ? 'red' : window.globals.strokeColor,
                  strokeWidth: window.globals.strokeWidth,
                  locked: true
              }).removeOnMove().removeOnDrag();
					}
				}

        var segment, path, handleIn, handleOut;
        var movePath = false;
        var drawn;
        function onMouseDown(event) {
            if (drawing) {
              project.clear();

              drawn = new Path({
                  segments: [event.point],
                  strokeColor: 'black',
                  strokeWidth: window.globals.strokeWidth,
                  fullySelected: true,
                  data: {z: []}
              });

              for (var i = 0; i < 100; i++) {
                drawn.data.z.push(10*i);
              }

              return;
            }


            segment = handleIn = handleOut = null;
            var hitResult = project.hitTest(event.point, hitOptions);

            if (!hitResult) {
                activeKnot.selected = !activeKnot.selected;
                return;
            }

            if (event.modifiers.shift) {
                if (hitResult.type == 'segment') {
                    hitResult.segment.remove();
                    hitResult.item.data.z.splice(hitResult.segment.index, 1);
                }

                else if (hitResult.item.data.kind == 'intersection') {
                };
                return;
            }

            if (hitResult) {
                if (hitResult.item.data.kind == 'intersection') {
                  activeKnot = hitResult.item.data.path;
                  var i = hitResult.item.data.i1;
                  intersectionWatcher[1][i] = !(intersectionWatcher[1][i]);
                }
                else if (hitResult.type == 'segment') {
                    activeKnot = hitResult.item;
                    segment = hitResult.segment;
                    activeKnot.selected = true;
                } else if (hitResult.type == 'stroke') {
                    activeKnot = hitResult.item;
                    var location = hitResult.location;
                    activeKnot.selected = true;
                    segment = activeKnot.insert(location.index + 1, event.point);
                }
                else if (hitResult.type == 'handle-in') {
                  handleIn = hitResult.segment;
                }
                else if (hitResult.type == 'handle-out') {
                  handleOut = hitResult.segment;
                }
              }

						showIntersections();
        }

        function onMouseMove(event) {
            if (!drawing) {
              showIntersections();
            }
        }
        function onMouseUp(event) {
          if (drawing) {
            if (globals.smooth) {drawn.simplify();}
            drawn.simplify(15);
          	drawn.fullySelected = true;

            drawn.closed = true;
            drawing = false;

            activeKnot = drawn.clone();
            drawn.remove();
          }

          else if (globals.smooth) activeKnot.smooth('geometric', 1);

        }
        function onMouseDrag(event) {
            if (drawing) {
              drawn.add(event.point);
              return;
            }
            if (segment) {

              segment.point += event.delta;

              var next = segment;
              var previous = segment;
              var delta = event.delta;
              for (var i=0; i < window.globals.neighbors; i++) {
                next = next.next;

                delta *= 0.5;
                previous = previous.previous;
                next.point += delta;
                previous.point += delta;
              }

              }

            else if (handleIn) {
              handleIn.handleIn += event.delta; // This doesn't work sometimes, for some reason
            }
            else if (handleOut) {handleOut.handleOut += event.delta;}
            showIntersections();
        }

        var speed = 10;
        var angularSpeed = 3;
        function onKeyDown(event) {
          var delta = new Point(0,0);
        	if(event.key == 'a') {
        		delta.x -= speed;
        	}
        	else if(event.key == 'd') {
        		delta.x += speed;
        	}
        	if(event.key == 'w') {
        		delta.y -= speed;
        	}
        	else if(event.key == 's') {
        		delta.y += speed;
        	}
        	activeKnot.translate(delta);

          if(event.key == 'e') {
        		activeKnot.rotate(angularSpeed);
        	}
          else if(event.key == 'q') {
        		activeKnot.rotate(-angularSpeed);
        	}
        }

        </script>
</head>
<body>
    <div style="text-align:center;">
      <canvas id="canvas" width="1000px;" height="500px;" ></canvas>
      <div style="margin:5%;">

        <button type="button" onclick="toSVG()">Export to SVG</button>
        <button type="button" onclick="toJSON()">Export to JSON</button>
        <button type="button" onclick="window.globals.select()">Select / Unselect everything</button>
        <button type="button" onclick="window.globals.draw();">Reset & Enter free Drawing!</button>
        <p>Drag k neighbors: <input type="range" min="0" max="3" value="0" class="slider"  onchange="window.globals.neighbors = this.value;"></p>
        <p>Gap Width: <input type="range" min="2" max="5" value="2" class="slider" onchange="window.globals.gapWidth = this.value;"></p>
        <p>Stroke Width: <input type="range" min="1" max="10" value="3" class="slider"  onchange="window.globals.strokeWidth = this.value; window.globals.updateStyle();"></p>
        <p>Show Intersections: <input type="checkbox" checked="true" onchange="window.globals.showIntersections = this.checked;"></p>
        <p>Force Smoothness (Potentially Destructive): <input type="checkbox" checked="false" onchange="window.globals.smooth = this.checked;"></p>
        <button type="button" onclick="window.globals.straighten()">Straighten! (Potentially Destructive)</button>
      </div>
    </div>

    <div style="margin:5%;">
      <h3>ðŸª¢ðŸª¢ Manual ðŸª¢ðŸª¢</h3>
      <p><b>Knottingham</b> is a tool that lets you draw and manipulate knot diagrams, sporting a clean yet somewhat hand-drawn look. To start knotting away, you may want to follow these steps:</p>
      <ul>
        <li>Create a knot by:</li>
        <ul>
          <li>Clicking on segments to add new nodes</li>
          <li>Clicking and dragging nodes to move them (drag k neighbors is useful to rescue nodes from below crossings)</li>
          <li>and finally clicking on the automatically detected crossings to switch them. (sadly a little volatile at the moment)</li>
          <li><b>or clicking on 'Drawing' to draw a new knot from scratch</b>!</li>
        </ul>
        <li>Adjust the knot by:</li>
        <ul>
          <li>Removing nodes with <b>Shift+Click</b></li>
          <li>Moving and rotating the knot with the <b>WASD+EQ</b> keys</li>
          <li>Selecting it through the select button and adjust Bezier handles</li>
          <li>Forcing smoothness (twice continuous differentiability, to be precise)</li>
          <li>Adjusting the style with the sliders</li>
        </ul>
        <li> Show the knot to your friends by:
          <ul>
            <li>Exporting it to SVG!</li>
          </ul>
        </li>
      </ul>

      These features are planned:
      <ul>
        <li>Loading JSON</li>
        <li>Properly permanent crossing topology</li>
        <li>Classification of knots through knot invariants (for single knots)</li>
        <li>Exporting to TikZ</li>
        <li>Non-Reidemeister Move-Detection</li>
        <li>Some more styling options</li>
        <li>Undoing</li>
        <li>Multiple intertwined knots</li>
      </ul>
      <p>Any and all feedback is appreciated! You can mail to <a href="mailto:developer/at/fi-le.net">developer/at/fi-le.net</a> </p>
    </div>
     <script type="text/javascript">
      window.globals = {neighbors:0, strokeWidth:5, gapWidth:2, strokeColor:'black', showIntersections:true, smooth:false};

      function toSVG() {
        // Kindly provided by users senz, Dave and defghi 1977
        // https://stackoverflow.com/questions/23218174/how-do-i-save-export-an-svg-file-after-creating-an-svg-with-d3-js-ie-safari-an
        var svg =  window.globals.toSVG();

        svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        var svgData = svg.outerHTML;
        var preface = '<?xml version="1.0" standalone="no"?>\r\n';
        var svgBlob = new Blob([preface, svgData], {type:"image/svg+xml;charset=utf-8"});
        var svgUrl = URL.createObjectURL(svgBlob);
        var downloadLink = document.createElement("a");
        downloadLink.href = svgUrl;
        downloadLink.download = name;
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
      }

      function toJSON() {
        // Many thanks to users bformet and volzoran
        // https://stackoverflow.com/questions/19721439/download-json-object-as-a-file-from-browser

        var jsonString =  window.globals.toJSON();
        var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(jsonString);
        var dl = document.createElement("a");
        dl.setAttribute("href", dataStr);
        dl.setAttribute("download", "knot.knottingham");
        dl.click();
        document.body.removeChild(dl);
      }
      </script>
</body>
</html>
